/*
    https://www.hackerrank.com/challenges/repeat-k-sums/problem

    Alice thinks of a non-decreasing sequence of non-negative integers and wants Bob to guess it by providing him the set of all its K-sums with repetitions.

    What is this? Let the sequence be {A[1], A[2], ..., A[N]} and K be some positive integer that both Alice and Bob know.
    Alice gives Bob the set of all possible values that can be generated by this - A[i1] + A[i2] + ... + A[iK], where 1 ≤ i1 ≤ i2 ≤ ... ≤ iK ≤ N. 
    She can provide the values generated in any order she wishes to. Bob's task is to restore the initial sequence.

    Consider an example. Let N = 3 and K = 2. The sequence is {A[1], A[2], A[3]}.
    The sequence of its 2-sums with repetitions is {A[1] + A[1], A[1] + A[2], A[1] + A[3], A[2] + A[2], A[2] + A[3], A[3] + A[3]}.
    But its elements could be provided in any order. For example any permutation of {2, 3, 4, 4, 5, 6} corresponds to the sequence {1, 2, 3}.

    Input Format

    The first line of the input contains an integer T denoting the number of test cases.
    The description of T test cases follows.
    The first line of each test case contains two space separated integers N and K.
    The second line contains the sequence Si of all K-sums with repetitions of the sequence Alice initially thought of.

    Constraints

    Note
    The total number of elements in any input sequence does not exceed 105
    Each element of each input sequence is non-negative integer not exceeding 1018.
    Each input sequence is a correct sequence of all K-sums with repetitions of some non-decreasing sequence of non-negative integers.

    Output Format

    For each test case, output a single line containing the space separated list of elements of the non-decreasing sequence Alice thinks of.
    If there are several possible outputs you can output any of them.

    Sample Input 0

    3
    1 3
    3
    2 2
    12 34 56
    3 2
    2 3 4 4 5 6
    Sample Output 0

    1
    6 28
    1 2 3
    Explanation 0

    Sample case #00: When N = 1 and K = 3 the only K-sum is S[1] = 3 * A[1]. Hence A[1] = S[1] / 3 = 3 / 3 = 1.

    Sample case #01: Since 6 + 6 = 12, 6 + 28 = 34, 28 + 28 = 56, then Alice indeed could think of the sequence {6, 28}.

    Sample case #02: It corresponds to the example in the problem statement.


    3 2
    2 4 5 6 7 8
    3 2
    2 4 6 8 10 14
    
    output:
    1 3 4
    1 3 7

 */

using System;
using System.Collections.Generic;
using System.Linq;

namespace Challenges.Algorithms.Advanced
{
    public class RepetitiveKSums
    {
        public static void Start(string[] args)
        {
            int numberOfTests = Convert.ToInt32(Console.ReadLine());
            var testCases = new int[numberOfTests][][];
            
            for (int i = 0; i < numberOfTests; i++)
            {
                int[] nAndk = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
                int[] kSums = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
                testCases[i] = new[] {nAndk, kSums};
            }
            
            for (int i = 0; i < numberOfTests; i++)
            {
                Console.WriteLine(string.Join(" ",GenerateInitialSequence(testCases[i])));
            }

        }

        private static List<int[]> Generate1Sum(int[] sequence)
        {
            List<int[]> TheSum = new List<int[]>();
            for (var i = 0; i < sequence.Length; i++)
            {
                TheSum.Add(new[]{sequence[i]});
            }

            return TheSum;
        }

        private static List<int[]> GeneratekSum(int k, int[] sequence)
        {
            if (k == 1) return Generate1Sum(sequence);

            List<int[]> ThePreviousSum = GeneratekSum(k - 1, sequence);

            List<int[]> TheKSum = new List<int[]>();

            for (var i = 0; i < ThePreviousSum.Count; i++)
            {
                var lastIndexValue = ThePreviousSum[i][k - 2];
                var lastIndex = Array.IndexOf<int>(sequence, lastIndexValue);
                for (var j = lastIndex; j < sequence.Length; j++)
                {
                    var newSum = ThePreviousSum[i].Concat(new[] {sequence[j]}).ToArray();
                    TheKSum.Add(newSum);
                }
            }


            return TheKSum;
        }

        private static int[] GetSubSequence(int start, int end, int[] sequence, int[] topLevelKSum, int k, int n)
        {
            for (var i = start; i < end; i++)
            {
                var newSequence = sequence.Concat(new[] {i, end}).ToArray();
                var ThePermutations = GeneratekSum(k, newSequence);
                var TheSum = ThePermutations.Select(x => x.Sum()).ToArray();
                if (IsValidSubKSum(topLevelKSum, TheSum))
                {
                    if (newSequence.Length == n) return newSequence;

                    return GetSubSequence(i + 1, end, sequence.Concat(new[]{i}).ToArray(), topLevelKSum, k, n);
                }
            }

            return sequence;
        }

        private static bool IsValidSubKSum(int[] topLevelKSum, int[] subKSum)
        {
            return !subKSum.Except(topLevelKSum).Any();
        }
        
        private static int[] GenerateInitialSequence(int[][] testCase)
        {
            int n = testCase[0][0]; // number of element in the sequence
            int k = testCase[0][1]; // the k sum (i.e. 2-sum, 3-sum...etc)
            int[] kSums = testCase[1]; // the array of k sums

            if (n == 1) return new[] {kSums[0] / k};

            var firstElement = kSums[0] / k;
            var lastElement = kSums[^1] / k;

            if (n == 2) return new[] {firstElement, lastElement};

            var sequence = GetSubSequence(firstElement + 1, lastElement, new int[]{firstElement}, kSums, k, n);

            return sequence;;
        }

    }
}