/*
    https://www.hackerrank.com/challenges/repeat-k-sums/problem

    Alice thinks of a non-decreasing sequence of non-negative integers and wants Bob to guess it by providing him the set of all its K-sums with repetitions.

    What is this? Let the sequence be {A[1], A[2], ..., A[N]} and K be some positive integer that both Alice and Bob know.
    Alice gives Bob the set of all possible values that can be generated by this - A[i1] + A[i2] + ... + A[iK], where 1 ≤ i1 ≤ i2 ≤ ... ≤ iK ≤ N. 
    She can provide the values generated in any order she wishes to. Bob's task is to restore the initial sequence.

    Consider an example. Let N = 3 and K = 2. The sequence is {A[1], A[2], A[3]}.
    The sequence of its 2-sums with repetitions is {A[1] + A[1], A[1] + A[2], A[1] + A[3], A[2] + A[2], A[2] + A[3], A[3] + A[3]}.
    But its elements could be provided in any order. For example any permutation of {2, 3, 4, 4, 5, 6} corresponds to the sequence {1, 2, 3}.

    Input Format

    The first line of the input contains an integer T denoting the number of test cases.
    The description of T test cases follows.
    The first line of each test case contains two space separated integers N and K.
    The second line contains the sequence Si of all K-sums with repetitions of the sequence Alice initially thought of.

    Constraints

    Note
    The total number of elements in any input sequence does not exceed 105
    Each element of each input sequence is non-negative integer not exceeding 1018.
    Each input sequence is a correct sequence of all K-sums with repetitions of some non-decreasing sequence of non-negative integers.

    Output Format

    For each test case, output a single line containing the space separated list of elements of the non-decreasing sequence Alice thinks of.
    If there are several possible outputs you can output any of them.

    Sample Input 0

    3
    1 3
    3
    2 2
    12 34 56
    3 2
    2 3 4 4 5 6
    Sample Output 0

    1
    6 28
    1 2 3
    Explanation 0

    Sample case #00: When N = 1 and K = 3 the only K-sum is S[1] = 3 * A[1]. Hence A[1] = S[1] / 3 = 3 / 3 = 1.

    Sample case #01: Since 6 + 6 = 12, 6 + 28 = 34, 28 + 28 = 56, then Alice indeed could think of the sequence {6, 28}.

    Sample case #02: It corresponds to the example in the problem statement.


    3 2
    2 4 5 6 7 8
    3 2
    2 4 6 8 10 14
    
    output:
    1 3 4
    1 3 7


    10
    10 1
    13 23 23 23 27 27 52 52 53 53
    11 1
    5 20 20 24 29 51 51 51 73 78 92
    3 3
    18 32 38 46 52 58 60 66 72 78
    4 3
    36 37 38 39 42 43 43 44 44 45 48 49 49 50 50 51 54 55 56 57
    1 8
    16
    4 2
    18 20 22 23 25 28 31 33 36 44
    2 18
    0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54
    2 19
    19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19
    5 2
    24 24 24 24 24 24 24 24 24 24 53 53 53 53 82
    3 4
    0 8 16 17 24 25 32 33 34 41 42 50 51 59 68

    Output
    13 23 23 23 27 27 52 52 53 53
    5 20 20 24 29 51 51 51 73 78 92
    6 20 26
    12 13 18 19
    2
    9 11 14 22
    0 3
    1 1
    12 12 12 12 41
    0 8 17

 */

using System;
using System.Collections.Generic;
using System.Linq;

namespace Challenges.Algorithms.Advanced
{
    public class RepetitiveKSums
    {
        public static void Start(string[] args)
        {
            int numberOfTests = Convert.ToInt32(Console.ReadLine());
            var testCases = new int[numberOfTests][][];
            
            for (int i = 0; i < numberOfTests; i++)
            {
                int[] nAndk = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
                int[] kSums = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
                testCases[i] = new[] {nAndk, kSums};
            }
            
            for (int i = 0; i < numberOfTests; i++)
            {
                Console.WriteLine(string.Join(" ",GenerateInitialSequence(testCases[i])));
            }

        }

        private static List<int[]> Generate1Sum(int length)
        {
            List<int[]> TheSum = new List<int[]>();
            for (var i = 0; i < length; i++)
            {
                TheSum.Add(new[]{i});
            }

            return TheSum;
        }

        private static List<int[]> GeneratekSum(int k, int length)
        {
            if (k == 1) return Generate1Sum(length);

            List<int[]> ThePreviousSum = GeneratekSum(k - 1, length);

            List<int[]> TheKSum = new List<int[]>();

            for (var i = 0; i < ThePreviousSum.Count; i++)
            {
                var lastIndex = ThePreviousSum[i][k - 2];
                for (var j = lastIndex; j < length; j++)
                {
                    var newSum = ThePreviousSum[i].Concat(new[] {j}).ToArray();
                    TheKSum.Add(newSum);
                }
            }


            return TheKSum;
        }

        private static int[] GetSubSequence(int[] currentSequence, int[] topLevelKSum, int k, int n)
        {
            if (n <= currentSequence.Length) return currentSequence;

            var lastElement = currentSequence[currentSequence.Length - 1];
            var secondToLastElement = currentSequence[currentSequence.Length - 2];

            for(var i = secondToLastElement; i <= lastElement; i++)
            {
                var newSequence = new int[currentSequence.Length + 1];
                Array.Copy(currentSequence, newSequence,currentSequence.Length-1);
                newSequence[newSequence.Length - 2] = i;
                newSequence[newSequence.Length - 1] = lastElement;
                var ThePermutations = GeneratekSum(k, newSequence.Length);
                var TheSum = ThePermutations.Select(p => p.Select(index => newSequence[index]).Sum()).ToArray();

                if (IsValidSubKSum(topLevelKSum, TheSum))
                {
                    return GetSubSequence(newSequence, topLevelKSum, k, n);
                }
            }

            return currentSequence;

        }

        private static bool IsValidSubKSum(int[] topLevelKSum, int[] subKSum)
        {
            if (subKSum.Except(topLevelKSum).Any()) return false;

            foreach (var sum in subKSum)
            {
                if (topLevelKSum.Count(s => s == sum) != subKSum.Count(s => s == sum)) return false;
            }

            return true;
        }
        
        private static int[] GenerateInitialSequence(int[][] testCase)
        {
            int n = testCase[0][0]; // number of element in the sequence
            int k = testCase[0][1]; // the k sum (i.e. 2-sum, 3-sum...etc)
            int[] kSums = testCase[1]; // the array of k sums

            if (n == 1) return new[] {kSums[0] / k};

            var firstElement = kSums.Min() / k;
            var lastElement = kSums.Max() / k;

            if (n == 2) return new[] {firstElement, lastElement};

            var sequence = GetSubSequence(new int[]{firstElement, lastElement}, kSums, k, n);

            return sequence;
        }

    }
}